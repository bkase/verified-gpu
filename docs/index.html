<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <title>VerifiedGPU Blelloch Scan (WebGPU Harness)</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <style>
      body { font-family: system-ui, sans-serif; margin: 2rem; background: #fafafa; }
      pre { background: #111; color: #0f0; padding: 1rem; overflow: auto; }
      button { padding: 0.5rem 1rem; font-size: 1rem; }
      #status { margin-top: 1rem; font-weight: 600; }
    </style>
  </head>
  <body>
    <h1>VerifiedGPU &mdash; Blelloch Scan (WebGPU)</h1>
    <p>
      This tiny harness fetches the certified WGSL emitted by the Lean proofs
      (<code>kernel.wgsl</code> in this folder), uploads 256 signed
      integers to a WebGPU storage buffer, dispatches one workgroup of 256
      threads, and checks the exclusive prefix sums against a CPU baseline.
    </p>
    <p>
      <strong>Note:</strong> WebGPU scripts must be served over HTTP(S); GitHub
      Pages already satisfies this requirement.
    </p>
    <button id="run">Run Blelloch Scan</button>
    <div id="status">Idle.</div>
    <h2>Results</h2>
    <pre id="output">(awaiting run)</pre>

    <script type="module">
      const statusEl = document.getElementById("status");
      const outputEl = document.getElementById("output");
      document.getElementById("run").addEventListener("click", () => run().catch(err => {
        console.error(err);
        statusEl.textContent = `Error: ${err.message ?? err}`;
      }));

      async function run() {
        if (!navigator.gpu) {
          throw new Error("WebGPU is not available in this browser.");
        }

        statusEl.textContent = "Requesting adapter/device…";
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          throw new Error("Failed to acquire GPU adapter.");
        }
        const device = await adapter.requestDevice();

        statusEl.textContent = "Fetching certified WGSL…";
        const response = await fetch("./kernel.wgsl");
        if (!response.ok) {
          throw new Error(`Unable to fetch kernel.wgsl: ${response.status}`);
        }
        const wgsl = await response.text();

        const module = device.createShaderModule({ code: wgsl });
        const pipeline = device.createComputePipeline({
          layout: "auto",
          compute: { module, entryPoint: "main" },
        });

        // Prepare pseudo-random signed input data (stable per run).
        const laneCount = 256;
        const raw = new Uint32Array(laneCount);
        crypto.getRandomValues(raw);
        const data = new Int32Array(laneCount);
        for (let i = 0; i < laneCount; ++i) {
          data[i] = (raw[i] % 2001) - 1000; // range [-1000, 1000]
        }

        // Storage buffer used by the certified kernel.
        const storageBuffer = device.createBuffer({
          size: data.byteLength,
          usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST | GPUBufferUsage.COPY_SRC,
        });
        device.queue.writeBuffer(storageBuffer, 0, data.buffer);

        // Readback buffer for the results.
        const readback = device.createBuffer({
          size: data.byteLength,
          usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
        });

        const bindGroup = device.createBindGroup({
          layout: pipeline.getBindGroupLayout(0),
          entries: [{ binding: 0, resource: { buffer: storageBuffer } }],
        });

        statusEl.textContent = "Dispatching compute work…";
        const encoder = device.createCommandEncoder();
        const pass = encoder.beginComputePass();
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        pass.dispatchWorkgroups(1);
        pass.end();
        encoder.copyBufferToBuffer(storageBuffer, 0, readback, 0, data.byteLength);
        device.queue.submit([encoder.finish()]);

        await readback.mapAsync(GPUMapMode.READ);
        const mapped = new Int32Array(readback.getMappedRange().slice(0));
        readback.unmap();

        const expected = cpuExclusiveScan(data);
        const ok = arraysEqual(mapped, expected);

        statusEl.textContent = ok ? "Success: GPU output matches CPU baseline." : "Mismatch detected!";
        outputEl.textContent = `Input  : ${formatArray(data)}\nExpected: ${formatArray(expected)}\nGPU     : ${formatArray(mapped)}`;
      }

      function cpuExclusiveScan(input) {
        const out = new Int32Array(input.length);
        let acc = 0;
        for (let i = 0; i < input.length; ++i) {
          out[i] = acc;
          acc += input[i];
        }
        return out;
      }

      function arraysEqual(a, b) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; ++i) if (a[i] !== b[i]) return false;
        return true;
      }

      function formatArray(arr) {
        return Array.from(arr).join(", ");
      }
    </script>
  </body>
</html>
